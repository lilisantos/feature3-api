'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var moment = require('moment');
var DateRange = require('moment-range'); // eslint-disable-line no-unused-vars
require('moment-recur-npm');

/**
 * @class AvailabilitySchedule
 * @author Philipp Gebauer https://github.com/fubar
 *
 * A simple availability schedule library
 *
 * See the readme for usage details.
 */

var AvailabilitySchedule = function () {

  /** @member {Date} AvailabilitySchedule#startDate */
  /** @member {Date} AvailabilitySchedule#endDate */
  /** @member {DateRange[]} AvailabilitySchedule#availabilities */

  /**
   * @param {string} startDate Start date of the schedule as an ISO 8601 string
   * @param {string} endDate End date of the schedule as an ISO 8601 string
   */
  function AvailabilitySchedule(startDate, endDate) {
    _classCallCheck(this, AvailabilitySchedule);

    this.startDate = new Date(startDate);
    this.endDate = new Date(endDate);
    this.availabilities = [];
  }

  /**
   * @private
   */


  _createClass(AvailabilitySchedule, [{
    key: 'sortByStartDate',
    value: function sortByStartDate() {
      this.availabilities = this.availabilities.sort(
      /**
       * @param {DateRange} a
       * @param {DateRange} b
       */
      function (a, b) {
        if (a.start < b.start) {
          return -1;
        }
        if (a.start > b.start) {
          return 1;
        }
        return 0;
      });
    }

    /**
     * Returns the index of the first range that overlaps the given one.
     *
     * @param {DateRange[]} ranges
     * @param {DateRange} range
     * @private
     * @returns {number}
     */

  }, {
    key: 'findIndexOfOverlappingRange',
    value: function findIndexOfOverlappingRange(ranges, range) {
      return ranges.findIndex(function (current) {
        return range.overlaps(current);
      });
    }

    /**
     * Returns the index of the first range whose end date matches given one's start date.
     *
     * @param {DateRange[]} ranges
     * @param {DateRange} range
     * @private
     * @returns {number}
     */

  }, {
    key: 'findIndexOfAdjacentRange',
    value: function findIndexOfAdjacentRange(ranges, range) {
      return ranges.findIndex(function (current) {
        return current.end.isSame(range.start);
      });
    }

    /**
     * Sorts availabilities by start date and joins any overlapping or adjacent ones into single availabilities.
     *
     * @private
     */

  }, {
    key: 'normalize',
    value: function normalize() {
      var _this = this;

      this.sortByStartDate();

      /** @type {DateRange[]} */
      var normalized = [];

      this.availabilities.map(function (availability) {

        // trim availabilities that overlap at the start or end of the schedule
        if (availability.start.toDate() < _this.startDate) {
          availability = moment.range(_this.startDate, availability.end);
        }
        if (availability.end.toDate() > _this.endDate) {
          availability = moment.range(availability.start, _this.endDate);
        }

        // combine overlapping (includes identical ranges which remain unchanged)
        var indexOverlapping = _this.findIndexOfOverlappingRange(normalized, availability);
        if (indexOverlapping > -1) {
          normalized[indexOverlapping] = normalized[indexOverlapping].add(availability);
          return;
        }
        // combine adjacent
        var indexAdjacent = _this.findIndexOfAdjacentRange(normalized, availability);
        if (indexAdjacent > -1) {
          normalized[indexAdjacent] = moment.range(normalized[indexAdjacent].start, availability.end);
          return;
        }
        normalized.push(availability);
      });
      this.availabilities = normalized;
    }

    /**
     * Adds an available time range
     *
     * @param {string} startDate ISO 8601 string
     * @param {string} endDate ISO 8601 string
     */

  }, {
    key: 'addAvailability',
    value: function addAvailability(startDate, endDate) {

      var momentStartUtc = moment(startDate).utc(); // equivalent to new Date(startDate)
      var momentEndUtc = moment(endDate).utc();

      if (momentEndUtc.toDate() <= this.startDate || momentStartUtc.toDate() >= this.endDate) {
        return;
      }
      this.availabilities.push(moment.range(momentStartUtc, momentEndUtc));
      this.normalize();
    }

    /**
     * Adds an available time range and repeats it on the given weekdays
     *
     * @param {string} startDate ISO 8601 string
     * @param {string} endDate ISO 8601 string
     * @param {number[]} repeatWeekdays Array of integers that indicate the weekdays on which the availability is repeated. 1 = Mon, 7 = Sun (in the same time zone as startDate).
     */

  }, {
    key: 'addWeeklyRecurringAvailability',
    value: function addWeeklyRecurringAvailability(startDate, endDate, repeatWeekdays) {
      var _this2 = this;

      var momentStartUtc = moment(startDate).utc(); // equivalent to new Date(startDate)
      var momentEndUtc = moment(endDate).utc();

      if (momentEndUtc <= momentStartUtc) {
        return;
      }
      if (momentStartUtc.toDate() >= this.endDate) {
        return;
      }
      this.addAvailability(startDate, endDate);

      if (!Array.isArray(repeatWeekdays)) {
        return;
      }
      repeatWeekdays = repeatWeekdays.filter(function (weekday) {
        return Number.isInteger(weekday) && weekday >= 0 && weekday <= 7;
      });
      if (!repeatWeekdays.length) {
        return;
      }
      var durationInMinutes = moment.range(momentStartUtc, momentEndUtc).diff('minutes');

      /**
       * By default, moment shifts the date to the local computer's timezone (go figure).
       * utcOffset() shifts the date to a given timezone and is able to extract the offset from a full time stamp.
       */
      var momentInTimezone = moment(startDate).utcOffset(startDate);
      var utcWeekdayDifference = momentInTimezone.isoWeekday() - momentStartUtc.isoWeekday();

      var repeatWeekdaysInUtc = repeatWeekdays.map(function (weekday) {
        return weekday - utcWeekdayDifference;
      }).map(function (weekday) {
        return weekday % 7;
      }) // enforces range -6..6
      .map(function (weekday) {
        return weekday < 1 ? weekday + 7 : weekday;
      }); // enforces range 1..7

      moment().recur(moment(momentStartUtc.toDate()).utc(), moment(this.endDate).utc()).every(repeatWeekdaysInUtc).daysOfWeek().all().map(function (date) {
        // moment-recur discards of time information. add it back
        return date.set('hour', momentStartUtc.get('hour')).set('minute', momentStartUtc.get('minute')).set('second', momentStartUtc.get('second'));
      }).map(function (date) {
        return moment.range(date, date.clone().add(durationInMinutes, 'minutes'));
      }).filter(function (range) {
        return range.end.toDate() > _this2.startDate && range.start.toDate() < _this2.endDate;
      }).map(function (range) {
        return _this2.availabilities.push(range);
      });

      this.normalize();
    }

    /**
     * Removes a time range from any existing availabilities
     *
     * @param {string} startDate ISO 8601 string
     * @param {string} endDate ISO 8601 string
     */

  }, {
    key: 'removeAvailability',
    value: function removeAvailability(startDate, endDate) {

      var range = moment.range(moment(startDate).utc(), moment(endDate).utc());

      /** @type {DateRange[]} */
      var remainders = [];

      this.availabilities.map(function (availability) {
        remainders.push.apply(remainders, _toConsumableArray(availability.subtract(range)));
      });
      this.availabilities = remainders;
    }

    /**
     * Returns all availabilities as an array of {start: date string, end: date string} objects in chronological order
     *
     * @param {String} timezone Accepts just the timezone offset such as "-05:00" as well as a full time stamp that includes the offset (e.g. "2000-01-01T00:00:00-04:00")
     * @returns {Array.<{start: string, end: string}>} An array of objects with ISO 8601 date strings like {start: '2000-01-01T00:00:00Z', end: '2000-01-01T00:30:00Z'}
     */

  }, {
    key: 'getAvailabilities',
    value: function getAvailabilities() {
      var timezone = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '+0000';

      return this.availabilities.map(function (availability) {
        return {
          start: availability.start.utcOffset(timezone).format(),
          end: availability.end.utcOffset(timezone).format()
        };
      });
    }

    /**
     * Returns true if the given time range falls within any availability
     *
     * @param {string} startDate ISO 8601 string
     * @param {string} endDate ISO 8601 string
     * @returns {boolean}
     */

  }, {
    key: 'isAvailable',
    value: function isAvailable(startDate, endDate) {

      var range = moment.range(moment(startDate).utc(), moment(endDate).utc());

      return !!this.availabilities.find(function (availability) {
        return range.start.within(availability) && range.end.within(availability);
      });
    }
  }]);

  return AvailabilitySchedule;
}();

module.exports = AvailabilitySchedule;